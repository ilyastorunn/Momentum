{"dependencies":[{"name":"./error.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":1,"column":0,"index":0},"end":{"line":1,"column":41,"index":41}}],"key":"ycPOBQoRsCJSxLowwoXjlScYLNE=","exportNames":["*"]}},{"name":"./syncpromise.js","data":{"asyncType":null,"isESMImport":true,"locs":[{"start":{"line":2,"column":0,"index":42},"end":{"line":2,"column":89,"index":131}}],"key":"r9D+KVM39qpXh7dXewX99qgTA/A=","exportNames":["*"]}}],"output":[{"data":{"code":"__d(function (global, require, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.makePromiseBuffer = makePromiseBuffer;\n  var _error = require(_dependencyMap[0], \"./error.js\");\n  var _syncpromise = require(_dependencyMap[1], \"./syncpromise.js\");\n  /**\n   * Creates an new PromiseBuffer object with the specified limit\n   * @param limit max number of promises that can be stored in the buffer\n   */\n  function makePromiseBuffer(limit) {\n    const buffer = [];\n    function isReady() {\n      return limit === undefined || buffer.length < limit;\n    }\n\n    /**\n     * Remove a promise from the queue.\n     *\n     * @param task Can be any PromiseLike<T>\n     * @returns Removed promise.\n     */\n    function remove(task) {\n      return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(undefined);\n    }\n\n    /**\n     * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n     *\n     * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n     *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n     *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n     *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n     *        limit check.\n     * @returns The original promise.\n     */\n    function add(taskProducer) {\n      if (!isReady()) {\n        return (0, _syncpromise.rejectedSyncPromise)(new _error.SentryError('Not adding Promise because buffer limit was reached.'));\n      }\n\n      // start the task and add its promise to the queue\n      const task = taskProducer();\n      if (buffer.indexOf(task) === -1) {\n        buffer.push(task);\n      }\n      void task.then(() => remove(task))\n      // Use `then(null, rejectionHandler)` rather than `catch(rejectionHandler)` so that we can use `PromiseLike`\n      // rather than `Promise`. `PromiseLike` doesn't have a `.catch` method, making its polyfill smaller. (ES5 didn't\n      // have promises, so TS has to polyfill when down-compiling.)\n      .then(null, () => remove(task).then(null, () => {\n        // We have to add another catch here because `remove()` starts a new promise chain.\n      }));\n      return task;\n    }\n\n    /**\n     * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n     *\n     * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n     * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n     * `true`.\n     * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n     * `false` otherwise\n     */\n    function drain(timeout) {\n      return new _syncpromise.SyncPromise((resolve, reject) => {\n        let counter = buffer.length;\n        if (!counter) {\n          return resolve(true);\n        }\n\n        // wait for `timeout` ms and then resolve to `false` (if not cancelled first)\n        const capturedSetTimeout = setTimeout(() => {\n          if (timeout && timeout > 0) {\n            resolve(false);\n          }\n        }, timeout);\n\n        // if all promises resolve in time, cancel the timer and resolve to `true`\n        buffer.forEach(item => {\n          void (0, _syncpromise.resolvedSyncPromise)(item).then(() => {\n            if (! --counter) {\n              clearTimeout(capturedSetTimeout);\n              resolve(true);\n            }\n          }, reject);\n        });\n      });\n    }\n    return {\n      $: buffer,\n      add,\n      drain\n    };\n  }\n});","lineCount":98,"map":[[6,2,1,0],[6,6,1,0,"_error"],[6,12,1,0],[6,15,1,0,"require"],[6,22,1,0],[6,23,1,0,"_dependencyMap"],[6,37,1,0],[7,2,2,0],[7,6,2,0,"_syncpromise"],[7,18,2,0],[7,21,2,0,"require"],[7,28,2,0],[7,29,2,0,"_dependencyMap"],[7,43,2,0],[8,2,4,0],[9,0,5,0],[10,0,6,0],[11,0,7,0],[12,2,8,0],[12,11,8,9,"makePromiseBuffer"],[12,28,8,26,"makePromiseBuffer"],[12,29,8,27,"limit"],[12,34,8,32],[12,36,8,34],[13,4,9,2],[13,10,9,8,"buffer"],[13,16,9,14],[13,19,9,17],[13,21,9,19],[14,4,11,2],[14,13,11,11,"isReady"],[14,20,11,18,"isReady"],[14,21,11,18],[14,23,11,21],[15,6,12,4],[15,13,12,11,"limit"],[15,18,12,16],[15,23,12,21,"undefined"],[15,32,12,30],[15,36,12,34,"buffer"],[15,42,12,40],[15,43,12,41,"length"],[15,49,12,47],[15,52,12,50,"limit"],[15,57,12,55],[16,4,13,2],[18,4,15,2],[19,0,16,0],[20,0,17,0],[21,0,18,0],[22,0,19,0],[23,0,20,0],[24,4,21,2],[24,13,21,11,"remove"],[24,19,21,17,"remove"],[24,20,21,18,"task"],[24,24,21,22],[24,26,21,24],[25,6,22,4],[25,13,22,11,"buffer"],[25,19,22,17],[25,20,22,18,"splice"],[25,26,22,24],[25,27,22,25,"buffer"],[25,33,22,31],[25,34,22,32,"indexOf"],[25,41,22,39],[25,42,22,40,"task"],[25,46,22,44],[25,47,22,45],[25,49,22,47],[25,50,22,48],[25,51,22,49],[25,52,22,50],[25,53,22,51],[25,54,22,52],[25,58,22,56,"Promise"],[25,65,22,63],[25,66,22,64,"resolve"],[25,73,22,71],[25,74,22,72,"undefined"],[25,83,22,81],[25,84,22,82],[26,4,23,2],[28,4,25,2],[29,0,26,0],[30,0,27,0],[31,0,28,0],[32,0,29,0],[33,0,30,0],[34,0,31,0],[35,0,32,0],[36,0,33,0],[37,0,34,0],[38,4,35,2],[38,13,35,11,"add"],[38,16,35,14,"add"],[38,17,35,15,"taskProducer"],[38,29,35,27],[38,31,35,29],[39,6,36,4],[39,10,36,8],[39,11,36,9,"isReady"],[39,18,36,16],[39,19,36,17],[39,20,36,18],[39,22,36,20],[40,8,37,6],[40,15,37,13],[40,19,37,13,"rejectedSyncPromise"],[40,51,37,32],[40,53,37,33],[40,57,37,37,"SentryError"],[40,75,37,48],[40,76,37,49],[40,130,37,103],[40,131,37,104],[40,132,37,105],[41,6,38,4],[43,6,40,4],[44,6,41,4],[44,12,41,10,"task"],[44,16,41,14],[44,19,41,17,"taskProducer"],[44,31,41,29],[44,32,41,30],[44,33,41,31],[45,6,42,4],[45,10,42,8,"buffer"],[45,16,42,14],[45,17,42,15,"indexOf"],[45,24,42,22],[45,25,42,23,"task"],[45,29,42,27],[45,30,42,28],[45,35,42,33],[45,36,42,34],[45,37,42,35],[45,39,42,37],[46,8,43,6,"buffer"],[46,14,43,12],[46,15,43,13,"push"],[46,19,43,17],[46,20,43,18,"task"],[46,24,43,22],[46,25,43,23],[47,6,44,4],[48,6,45,4],[48,11,45,9,"task"],[48,15,45,13],[48,16,46,7,"then"],[48,20,46,11],[48,21,46,12],[48,27,46,18,"remove"],[48,33,46,24],[48,34,46,25,"task"],[48,38,46,29],[48,39,46,30],[49,6,47,6],[50,6,48,6],[51,6,49,6],[52,6,49,6],[52,7,50,7,"then"],[52,11,50,11],[52,12,50,12],[52,16,50,16],[52,18,50,18],[52,24,51,8,"remove"],[52,30,51,14],[52,31,51,15,"task"],[52,35,51,19],[52,36,51,20],[52,37,51,21,"then"],[52,41,51,25],[52,42,51,26],[52,46,51,30],[52,48,51,32],[52,54,51,38],[53,8,52,10],[54,6,52,10],[54,7,53,9],[54,8,54,6],[54,9,54,7],[55,6,55,4],[55,13,55,11,"task"],[55,17,55,15],[56,4,56,2],[58,4,58,2],[59,0,59,0],[60,0,60,0],[61,0,61,0],[62,0,62,0],[63,0,63,0],[64,0,64,0],[65,0,65,0],[66,0,66,0],[67,4,67,2],[67,13,67,11,"drain"],[67,18,67,16,"drain"],[67,19,67,17,"timeout"],[67,26,67,24],[67,28,67,26],[68,6,68,4],[68,13,68,11],[68,17,68,15,"SyncPromise"],[68,41,68,26],[68,42,68,27],[68,43,68,28,"resolve"],[68,50,68,35],[68,52,68,37,"reject"],[68,58,68,43],[68,63,68,48],[69,8,69,6],[69,12,69,10,"counter"],[69,19,69,17],[69,22,69,20,"buffer"],[69,28,69,26],[69,29,69,27,"length"],[69,35,69,33],[70,8,71,6],[70,12,71,10],[70,13,71,11,"counter"],[70,20,71,18],[70,22,71,20],[71,10,72,8],[71,17,72,15,"resolve"],[71,24,72,22],[71,25,72,23],[71,29,72,27],[71,30,72,28],[72,8,73,6],[74,8,75,6],[75,8,76,6],[75,14,76,12,"capturedSetTimeout"],[75,32,76,30],[75,35,76,33,"setTimeout"],[75,45,76,43],[75,46,76,44],[75,52,76,50],[76,10,77,8],[76,14,77,12,"timeout"],[76,21,77,19],[76,25,77,23,"timeout"],[76,32,77,30],[76,35,77,33],[76,36,77,34],[76,38,77,36],[77,12,78,10,"resolve"],[77,19,78,17],[77,20,78,18],[77,25,78,23],[77,26,78,24],[78,10,79,8],[79,8,80,6],[79,9,80,7],[79,11,80,9,"timeout"],[79,18,80,16],[79,19,80,17],[81,8,82,6],[82,8,83,6,"buffer"],[82,14,83,12],[82,15,83,13,"forEach"],[82,22,83,20],[82,23,83,21,"item"],[82,27,83,25],[82,31,83,29],[83,10,84,8],[83,15,84,13],[83,19,84,13,"resolvedSyncPromise"],[83,51,84,32],[83,53,84,33,"item"],[83,57,84,37],[83,58,84,38],[83,59,84,39,"then"],[83,63,84,43],[83,64,84,44],[83,70,84,50],[84,12,85,10],[84,16,85,14],[84,17,85,15],[84,20,85,17,"counter"],[84,27,85,24],[84,29,85,26],[85,14,86,12,"clearTimeout"],[85,26,86,24],[85,27,86,25,"capturedSetTimeout"],[85,45,86,43],[85,46,86,44],[86,14,87,12,"resolve"],[86,21,87,19],[86,22,87,20],[86,26,87,24],[86,27,87,25],[87,12,88,10],[88,10,89,8],[88,11,89,9],[88,13,89,11,"reject"],[88,19,89,17],[88,20,89,18],[89,8,90,6],[89,9,90,7],[89,10,90,8],[90,6,91,4],[90,7,91,5],[90,8,91,6],[91,4,92,2],[92,4,94,2],[92,11,94,9],[93,6,95,4,"$"],[93,7,95,5],[93,9,95,7,"buffer"],[93,15,95,13],[94,6,96,4,"add"],[94,9,96,7],[95,6,97,4,"drain"],[96,4,98,2],[96,5,98,3],[97,2,99,0],[98,0,99,1],[98,3]],"functionMap":{"names":["<global>","makePromiseBuffer","isReady","remove","add","task.then$argument_0","task.then.then$argument_1","remove.then$argument_1","drain","SyncPromise$argument_0","setTimeout$argument_0","buffer.forEach$argument_0","resolvedSyncPromise.then$argument_0"],"mappings":"AAA;ACO;ECG;GDE;EEQ;GFE;EGY;YCW,kBD;kBEI;gCCC;SDE,CF;GHG;EOW;2BCC;4CCQ;ODI;qBEG;4CCC;SDK;OFC;KDC;GPC;CDO"}},"type":"js/module"}]}